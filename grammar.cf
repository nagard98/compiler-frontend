comment "{";
comment "{*" "*}" ; 

entrypoints P;

Prog.               P ::= PBlock [DclBlock] BEBlock ".";
ProgBlock.          PBlock ::= "program" Ident ";" ;

BegEndBlock.        BEBlock ::= "begin" [BegEndStmt] "end" ;

rules               BegEndStmt ::= Stmt ";" | DclBlock;
separator BegEndStmt "";

StmtComp.           Stmt ::= BEBlock ;
StmtAssign.         Stmt ::= LEXPR ":=" REXPR;
StmtCall.           Stmt ::= Call ;
StmtSelect.         Stmt ::= SelStmt ;
StmtIter.           Stmt ::= IterStmt;
StmtReturn.         Stmt ::= Return;

StmtIf.             SelStmt ::= "if" REXPR "then" Stmt ;
StmtIfElse.         SelStmt ::= "if" REXPR "then" Stmt "else" Stmt;

StmtWhileDo.        IterStmt ::= "while" REXPR "do" Stmt;
StmtRepeat.         IterStmt ::= "repeat" Stmt "until" REXPR;

Ret.                Return ::= "return" REXPR;

rules               DclBlock ::= PcBlock | VrBlock | FcBlock | CsBlock;
separator DclBlock "";

ProcBlock.          PcBlock ::= "procedure" Ident Prms ";" BEBlock ";";
FuncBlock.          FcBlock ::= "function" Ident Prms ":" Type ";" BEBlock ";" ;

Params.             Prms ::= "(" [Prm] ")";
NoParams.           Prms ::= ;
Param.              Prm ::= Modality [IdElem] ":" Type;
rules               Modality ::= "var" | {-empty-};
separator nonempty Prm "," ;

CallArgs.           Call ::= Ident "(" [REXPR] ")";
separator REXPR ",";

VarBlock.           VrBlock ::= "var" [VrDef] ;
VarDefinition.      VrDef ::= [IdElem] ":" Type;
terminator nonempty VrDef ";" ;

ConstBlock.         CsBlock ::= "const" [CsDef];
--TODO: valutare quali tipi possono essere costanti
--TODO: forse possibile iniziallizzare con una costante prima definita; possiamo valutare pi√π tardi; [NON FONDAMENTALE]
ConstDefinition.    CsDef ::= IdElem "=" Literal;
terminator nonempty CsDef ";";

IdElement.          IdElem ::= Ident;
separator nonempty IdElem ",";

rules               Boolean ::= "true" | "false" ;

rules               Type ::= BaseType | CompType;  
rules               BaseType ::= "integer" | "boolean" | "real" | "char" | "string" ;
rules               CompType ::= "array" "[" Integer ".." Integer "]" "of" Type | "^" BaseType ;

coercions REXPR 12;

Or.                 REXPR ::= REXPR "or" REXPR1;
And.                REXPR1 ::= REXPR1 "and" REXPR2;
Not.                REXPR2 ::= "not" REXPR3;

Eq.                 REXPR3 ::= REXPR4 "=" REXPR4 ;
NotEq.              REXPR3 ::= REXPR4 "<>" REXPR4;
LessT.              REXPR3 ::= REXPR4 "<" REXPR4;
EqLessT.            REXPR3 ::= REXPR4 "<=" REXPR4;
GreatT.             REXPR3 ::= REXPR4 ">" REXPR4;
EqGreatT.           REXPR3 ::= REXPR4 ">=" REXPR4;

Sub.                REXPR4 ::= REXPR4 "-" REXPR5;
Add.                REXPR5 ::= REXPR5 "+" REXPR6;
Div.                REXPR6 ::= REXPR6 "/" REXPR7;
Mul.                REXPR7 ::= REXPR7 "*" REXPR8;
Mod.                REXPR8 ::= REXPR8 "mod" REXPR9;

Negation.           REXPR9 ::= "-" REXPR10;
Reference.          REXPR9 ::= "@" REXPR10;
Dereference.        REXPR9 ::= REXPR10 "^";

ExprLiteral.        REXPR10 ::= Literal;

ExprCall.           REXPR11 ::= Call;

LExpression.        REXPR12 ::= LEXPR;

BaseLExpr.          LEXPR ::= BLEXPR;

Identifier.         BLEXPR ::= Ident;
ArrayElem.          BLEXPR ::= BLEXPR "[" REXPR "]";

rules Literal ::= Integer | String | Char | Double | Boolean ;