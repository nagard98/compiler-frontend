comment "{";
comment "{*" "*}" ; 

entrypoints P;

Prog.               P ::= PBlock [DclBlock] BEBlock ".";
ProgBlock.          PBlock ::= "program" Ident ";" ;

BegEndBlock.        BEBlock ::= "begin" [BegEndStmt] "end" ;

rules               BegEndStmt ::= Stmt ";" | DclBlock;
separator BegEndStmt "";

StmtComp.           Stmt ::= BEBlock ;
StmtAssign.         Stmt ::= EXPR ":=" EXPR;
StmtCall.           Stmt ::= Call ;
StmtSelect.         Stmt ::= SelStmt ;
StmtIter.           Stmt ::= IterStmt;
StmtReturn.         Stmt ::= Return;

StmtIf.             SelStmt ::= "if" EXPR "then" Stmt ;
StmtIfElse.         SelStmt ::= "if" EXPR "then" Stmt "else" Stmt;

StmtWhileDo.        IterStmt ::= "while" EXPR "do" Stmt;
StmtRepeat.         IterStmt ::= "repeat" Stmt "until" EXPR;

Ret.                Return ::= "return" EXPR;

rules               DclBlock ::= PcBlock | VrBlock | FcBlock | CsBlock;
separator DclBlock "";

ProcBlock.          PcBlock ::= "procedure" Ident Prms ";" BEBlock ";";
FuncBlock.          FcBlock ::= "function" Ident Prms ":" Type ";" BEBlock ";" ;

Params.             Prms ::= "(" [Prm] ")";
NoParams.           Prms ::= ;
Param.              Prm ::= Modality [IdElem] ":" Type;
rules               Modality ::= "var" | {-empty-};
separator nonempty Prm "," ;

CallArgs.           Call ::= Ident "(" [EXPR] ")";
separator EXPR ",";

VarBlock.           VrBlock ::= "var" [VrDef] ;
VarDefinition.      VrDef ::= [IdElem] ":" Type;
terminator nonempty VrDef ";" ;

ConstBlock.         CsBlock ::= "const" [CsDef];
--TODO: valutare quali tipi possono essere costanti
--TODO: forse possibile iniziallizzare con una costante prima definita; possiamo valutare pi√π tardi; [NON FONDAMENTALE]
ConstDefinition.    CsDef ::= IdElem "=" Literal;
terminator nonempty CsDef ";";

IdElement.          IdElem ::= Ident;
separator nonempty IdElem ",";

rules               Boolean ::= "true" | "false" ;

rules               Type ::= BaseType | CompType;  
rules               BaseType ::= "integer" | "boolean" | "real" | "char" | "string" ;
rules               CompType ::= "array" "[" Integer ".." Integer "]" "of" Type | "^" BaseType ;

coercions EXPR 13;

Or.                 EXPR ::= EXPR "or" EXPR1;
And.                EXPR1 ::= EXPR1 "and" EXPR2;
Not.                EXPR2 ::= "not" EXPR3;

Eq.                 EXPR3 ::= EXPR4 "=" EXPR4 ;
NotEq.              EXPR3 ::= EXPR4 "<>" EXPR4;
LessT.              EXPR3 ::= EXPR4 "<" EXPR4;
EqLessT.            EXPR3 ::= EXPR4 "<=" EXPR4;
GreatT.             EXPR3 ::= EXPR4 ">" EXPR4;
EqGreatT.           EXPR3 ::= EXPR4 ">=" EXPR4;

Sub.                EXPR4 ::= EXPR4 "-" EXPR5;
Add.                EXPR5 ::= EXPR5 "+" EXPR6;
Div.                EXPR6 ::= EXPR6 "/" EXPR7;
Mul.                EXPR7 ::= EXPR7 "*" EXPR8;
Mod.                EXPR8 ::= EXPR8 "mod" EXPR9;

Negation.           EXPR9 ::= "-" EXPR10;
Reference.          EXPR9 ::= "@" EXPR10;
Dereference.        EXPR9 ::= EXPR10 "^";

ExprLiteral.        EXPR10 ::= Literal;

ExprCall.           EXPR11 ::= Call;

BaseExpr.           EXPR12 ::= BEXPR;

Identifier.         BEXPR ::= Ident;
ArrayElem.          BEXPR ::= BEXPR "[" EXPR "]";

rules Literal ::= Integer | String | Char | Double | Boolean ;
