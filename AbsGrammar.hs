-- File generated by the BNF Converter (bnfc 2.9.4.1).

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

-- | The abstract syntax of language grammar.

module AbsGrammar where

import Prelude (Char, Double, Integer, String)
import qualified Prelude as C (Eq, Ord, Show, Read)
import qualified Data.String

data P = Prog PBlock [DclBlock] BEBlock
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data PBlock = ProgBlock Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BEBlock = BegEndBlock [BegEndStmt]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BegEndStmt = BegEndStmt1 Stmt | BegEndStmtDclBlock DclBlock
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Stmt
    = StmtComp BEBlock
    | StmtAssign LEXPR REXPR
    | StmtCall Call
    | StmtSelect SelStmt
    | StmtIter IterStmt
    | StmtReturn Return
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data SelStmt = StmtIf REXPR Stmt | StmtIfElse REXPR Stmt Stmt
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data IterStmt = StmtWhileDo REXPR Stmt | StmtRepeat Stmt REXPR
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Return = Ret REXPR
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data DclBlock
    = DclBlockPcBlock PcBlock
    | DclBlockVrBlock VrBlock
    | DclBlockFcBlock FcBlock
    | DclBlockCsBlock CsBlock
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data PcBlock = ProcBlock Ident Prms BEBlock
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FcBlock = FuncBlock Ident Prms Type BEBlock
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Prms = Params [Prm] | NoParams
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Prm = Param Modality [IdElem] Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Modality = Modality_var | Modality1
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Call = CallArgs Ident [REXPR]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data VrBlock = VarBlock [VrDef]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data VrDef = VarDefinition [IdElem] Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data CsBlock = ConstBlock [CsDef]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data CsDef = ConstDefinition IdElem Literal
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data IdElem = IdElement Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Boolean = Boolean_true | Boolean_false
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Type = TypeBaseType BaseType | TypeCompType CompType
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BaseType
    = BaseType_integer
    | BaseType_boolean
    | BaseType_real
    | BaseType_char
    | BaseType_string
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data CompType = CompType1 Integer Integer Type | CompType2 BaseType
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data REXPR
    = UnaryExpression {operator1 :: UnaryOperator, exp :: REXPR}
    | BinaryExpression {operator2 :: BinaryOperator, exp1, exp2 :: REXPR}
    | ExprLiteral Literal
    | ExprCall Call
    | LExpression LEXPR
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BinaryOperator = Or | And | Eq | NotEq | LessT | EqLessT | GreatT | EqGreatT | Sub | Add |
                      Div | Mul | Mod deriving (C.Eq, C.Ord, C.Show, C.Read)

data UnaryOperator = Not | Negation | Reference | Dereference deriving (C.Eq, C.Ord, C.Show, C.Read)

data LEXPR = BaseLExpr BLEXPR
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BLEXPR = Identifier Ident | ArrayElem BLEXPR REXPR
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Literal
    = LiteralInteger Integer
    | LiteralString String
    | LiteralChar Char
    | LiteralDouble Double
    | LiteralBoolean Boolean
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

